{"version":3,"sources":["catalog.js"],"names":["name","fromPairs","pairs","result","key","value","initialState","categories","currentPage","pageSize","prevPageTotal","rootCategoryId","reducerMap","actions","updateCategories","state","payload","id","currentCategory","children","sort","a","b","position","childMap","Map","child","set","parentId","keys","children_count","size","setRootCategory","setCurrentPage","receive","error","setPrevPageTotal"],"mappings":"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","sourcesContent":["import { handleActions } from 'redux-actions';\n\nimport actions from '../actions/catalog';\n\nexport const name = 'catalog';\n\nconst fromPairs = pairs => {\n    const result = {};\n\n    for (const [key, value] of pairs) {\n        result[key] = value;\n    }\n\n    return result;\n};\n\nconst initialState = {\n    categories: {},\n    currentPage: 1,\n    pageSize: 6,\n    prevPageTotal: null,\n    rootCategoryId: 2\n};\n\nconst reducerMap = {\n    [actions.updateCategories]: (state, { payload }) => {\n        const { id } = payload;\n        const currentCategory = state.categories[id] || {};\n\n        // if category has already been fetched, do nothing\n        if (currentCategory.children) {\n            return state;\n        }\n\n        // sort children by `position`\n        const children = [...payload.children].sort((a, b) => {\n            if (a.position > b.position) {\n                return 1;\n            } else if (a.position === b.position && a.id > b.id) {\n                return 1;\n            } else {\n                return -1;\n            }\n        });\n\n        // use a Map to preserve sort order\n        // since a plain object with numeric keys would lose it\n        const childMap = new Map();\n\n        // merge children and add them to the Map, keyed by `id`\n        for (const child of children) {\n            childMap.set(child.id, {\n                ...child,\n                ...(state.categories[child.id] || {}),\n                parentId: id\n            });\n        }\n\n        // merge in the fetched child last\n        return {\n            ...state,\n            categories: {\n                ...state.categories,\n                ...fromPairs(childMap),\n                [id]: {\n                    ...currentCategory,\n                    ...payload,\n                    children: [...childMap.keys()],\n                    children_count: childMap.size\n                }\n            }\n        };\n    },\n    [actions.setRootCategory]: (state, { payload }) => {\n        return {\n            ...state,\n            rootCategoryId: payload\n        };\n    },\n    [actions.setCurrentPage.receive]: (state, { payload, error }) => {\n        if (error) {\n            return state;\n        }\n\n        return {\n            ...state,\n            currentPage: payload\n        };\n    },\n    [actions.setPrevPageTotal.receive]: (state, { payload, error }) => {\n        if (error) {\n            return state;\n        }\n\n        return {\n            ...state,\n            prevPageTotal: payload\n        };\n    }\n};\n\nexport default handleActions(reducerMap, initialState);\n"]}