{"version":3,"sources":["useListState.js"],"names":["useListState","getItemKey","initialSelection","onSelectionChange","selectionModel","initialState","getInitialState","state","dispatch","wrappedReducer","selectedKeys","removeFocus","type","setFocus","key","payload","updateSelectedKeys","api","reducer","hasFocus","cursor","newSelectedKeys","updateSelectedKeysInternal","initiallySelectedKeys","getInitiallySelectedKeys","Set","target","Array","isArray","itemKey","map","add","has","delete"],"mappings":"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","sourcesContent":["import { useMemo, useReducer, useCallback, useEffect } from 'react';\n\nimport withLogger from '../util/withLogger';\n\n/**\n * A [React Hook]{@link https://reactjs.org/docs/hooks-intro.html} that contains\n * logic for handling a list of items.\n *\n * It returns the state of the list and an API object for managing the items in the list.\n *\n * @typedef {function} useListState\n *\n * @param {Object} config - an object containing:\n * @param {Func}    getItemKey - A function to get an Item's key.\n * @param {Array}   initialSelection - An array of keys that should be selected.\n * @param {string}  selectionModel - The list's selection type (radio or checkbox).\n * @param {function(Set):void} onSelectionChange - function to be called when the List selection changes.\n *\n * @return {Object[]} An array with two entries containing the following content: [ {@link ListState}, {@link API}]\n */\nexport const useListState = ({\n    getItemKey,\n    initialSelection,\n    onSelectionChange,\n    selectionModel\n}) => {\n    const initialState = useMemo(\n        () => getInitialState({ getItemKey, initialSelection, selectionModel }),\n        [getItemKey, initialSelection, selectionModel]\n    );\n\n    const [state, dispatch] = useReducer(wrappedReducer, initialState);\n    const { selectedKeys } = state;\n\n    // Whenever the selectedKeys changes, notify.\n    useEffect(() => {\n        if (onSelectionChange) {\n            onSelectionChange(selectedKeys);\n        }\n    }, [onSelectionChange, selectedKeys]);\n\n    /*\n     *  Functions of the API.\n     */\n\n    /**\n     * Function to remove focus on any item if it has focus.\n     *\n     * @typedef {function} removeFocus\n     *\n     * @param {void}\n     * @returns {void}\n     */\n    const removeFocus = useCallback(\n        () => dispatch({ type: 'REMOVE_FOCUS' }),\n        []\n    );\n\n    /**\n     * Function to set focus on a given item in the list.\n     *\n     * @typedef {function} setFocus\n     *\n     * @param {Key} key - Key of the item to set focus on.\n     * @returns {void}\n     */\n    const setFocus = useCallback(\n        key => dispatch({ type: 'SET_FOCUS', payload: { key } }),\n        []\n    );\n\n    /**\n     * Function to update the selected keys.\n     *\n     * @typedef {function} updateSelectedKeys\n     *\n     * @param {Key} key - The key of the item in the list to select (or deselect).\n     * @returns {void}\n     */\n    const updateSelectedKeys = useCallback(\n        key =>\n            dispatch({\n                type: 'UPDATE_SELECTED_KEYS',\n                payload: { key, selectionModel }\n            }),\n        [selectionModel]\n    );\n\n    /**\n     * The API for managing the Items inside the List.\n     *\n     * This object should never change.\n     * @typedef {Object} API\n     *\n     * @property {setFocus} setFocus\n     * @property {removeFocus} removeFocus\n     * @property {updateSelectedKeys} updateSelectedKeys\n     */\n\n    const api = useMemo(\n        () => ({\n            setFocus,\n            removeFocus,\n            updateSelectedKeys\n        }),\n        [setFocus, removeFocus, updateSelectedKeys]\n    );\n\n    return [state, api];\n};\n\n/**\n * Reducer function that is used by the useReducer hook inside the useListState hook.\n *\n * @function reducer\n *\n * @param {ListState} state\n * @param {Object} action - object that contains:\n * @param {string} action.type\n * @param {Object} action.payload - object that contains:\n * @param {Key} action.payload.key\n * @param {string} action.payload.selectionModel\n */\nconst reducer = (state, { type, payload }) => {\n    const { selectedKeys } = state;\n\n    switch (type) {\n        case 'REMOVE_FOCUS':\n            return {\n                ...state,\n                hasFocus: false\n            };\n        case 'SET_FOCUS':\n            return {\n                ...state,\n                hasFocus: true,\n                cursor: payload.key\n            };\n        case 'UPDATE_SELECTED_KEYS': {\n            const { key, selectionModel } = payload;\n            const newSelectedKeys = updateSelectedKeysInternal(\n                key,\n                selectedKeys,\n                selectionModel\n            );\n\n            return {\n                ...state,\n                selectedKeys: newSelectedKeys\n            };\n        }\n        default:\n            return state;\n    }\n};\n\nconst wrappedReducer = withLogger(reducer);\n\n/**\n * Helper function to update the List's Set of selected keys.\n *\n * @function getInitialState\n *\n * @param {Object}  options - an object containing:\n * @param {Func}    getItemKey - Get an item's key.\n * @param {Array}   initialSelection - An array of keys that should be selected initially.\n * @param {string}  selectionModel\n *\n * @returns {Object} - {@link ListState}\n */\nconst getInitialState = ({ getItemKey, initialSelection, selectionModel }) => {\n    const initiallySelectedKeys = getInitiallySelectedKeys({\n        getItemKey,\n        initialSelection,\n        selectionModel\n    });\n\n    return {\n        cursor: null,\n        hasFocus: false,\n        selectedKeys: new Set(initiallySelectedKeys)\n    };\n};\n\n/**\n * Helper function to validate and set the initial list of selected keys.\n *\n * @param {Object}  options - an object containing:\n * @param {Func}    getItemKey - Get an item's key.\n * @param {Array}   initialSelection - An array of keys that should be selected initially.\n * @param {string}  selectionModel\n * @returns {Array} an array containing initial item keys\n */\nconst getInitiallySelectedKeys = ({\n    getItemKey,\n    initialSelection,\n    selectionModel\n}) => {\n    if (!initialSelection) {\n        return null;\n    }\n\n    // We store the keys of each item that is initially selected,\n    // but we must also respect the selection model.\n    if (selectionModel === 'radio') {\n        // Only one thing can be selected at a time.\n        const target = Array.isArray(initialSelection)\n            ? initialSelection[0]\n            : initialSelection;\n\n        const itemKey = getItemKey(target);\n\n        if (itemKey) {\n            return [itemKey];\n        }\n\n        return [];\n    }\n\n    if (selectionModel === 'checkbox') {\n        // Multiple things can be selected at a time.\n\n        // Do we have multiple things?\n        if (Array.isArray(initialSelection)) {\n            return initialSelection.map(getItemKey);\n        }\n\n        const itemKey = getItemKey(initialSelection);\n\n        if (itemKey) {\n            return [itemKey];\n        }\n\n        return [];\n    }\n};\n\n/**\n * Helper function to update the List's Set of selected keys.\n *\n * @function updateSelectedKeysInternal\n *\n * @param {Key} key - The key to update (add to or remove from) the Set.\n * @param {Set} selectedKeys - The keys that are currently in the Set.\n * @param {Set} selectionModel - One of \"radio\" or \"checkbox\".\n *  Informs whether multiple keys can be selected at the same time.\n *\n * @returns {Set} - The new Set of selectedKeys.\n */\nconst updateSelectedKeysInternal = (key, selectedKeys, selectionModel) => {\n    let newSelectedKeys;\n\n    if (selectionModel === 'radio') {\n        // For radio, only one item can be selected at a time.\n        newSelectedKeys = new Set().add(key);\n    }\n\n    if (selectionModel === 'checkbox') {\n        newSelectedKeys = new Set(selectedKeys);\n\n        if (!newSelectedKeys.has(key)) {\n            // The item is being selected.\n            newSelectedKeys.add(key);\n        } else {\n            // The item is being deselected.\n            newSelectedKeys.delete(key);\n        }\n    }\n\n    return newSelectedKeys;\n};\n\n// Custom Type Definitions\n\n/**\n * Item's key type.\n *\n * @typedef {(string|number)} Key\n */\n\n/**\n * The current state of the List.\n *\n * @typedef {Object} ListState\n *\n * @property {Key} cursor\n * @property {boolean} hasFocus\n * @property {Set} selectedKeys\n */\n"]}