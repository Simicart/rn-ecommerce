{"version":3,"sources":["helpers.js"],"names":["DELIMITER","getSearchFromState","initialValue","filterKeys","filterState","nextParams","URLSearchParams","key","delete","group","items","item","title","value","append","toString","getStateFromSearch","filterItems","params","uniqueKeys","Set","keys","nextState","Map","has","endsWith","slice","groupItemsByValue","get","set","getAll","existingFilter","getValueFromFilterString","add","console","warn","getFiltersFromSearch","filters","stripHtml","html","replace","keyValueString","split","toRangeFilter","values","rangeString","Array","from","to","rangeFilter","toEqualFilter","size","in","map","eq","toMatchFilter","match","CONVERSION_FUNCTIONS","FilterEqualTypeInput","FilterMatchTypeInput","FilterRangeTypeInput","getFilterInput","type","conversionFunction","TypeError"],"mappings":"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","sourcesContent":["export const DELIMITER = ',';\nexport const getSearchFromState = (initialValue, filterKeys, filterState) => {\n    // preserve all existing params\n    const nextParams = new URLSearchParams(initialValue);\n\n    // iterate over available filters\n    for (const key of filterKeys) {\n        // remove any existing filter values\n        nextParams.delete(key);\n    }\n\n    // iterate over the latest filter values\n    for (const [group, items] of filterState) {\n        for (const item of items) {\n            const { title, value } = item || {};\n\n            // append the new values\n            nextParams.append(\n                `${group}[filter]`,\n                `${title}${DELIMITER}${value}`\n            );\n        }\n    }\n\n    // prepend `?` to the final string\n    return `?${nextParams.toString()}`;\n};\n\nexport const getStateFromSearch = (initialValue, filterKeys, filterItems) => {\n    // preserve all existing params\n    const params = new URLSearchParams(initialValue);\n    const uniqueKeys = new Set(params.keys());\n    const nextState = new Map();\n\n    // iterate over existing param keys\n    for (const key of uniqueKeys) {\n        // if a key matches a known filter, add its items to the next state\n        if (filterKeys.has(key) && key.endsWith('[filter]')) {\n            // derive the group by slicing off `[filter]`\n            const group = key.slice(0, -8);\n            const items = new Set();\n            const groupItemsByValue = new Map();\n\n            // cache items by value to avoid inefficient lookups\n            for (const item of filterItems.get(group)) {\n                groupItemsByValue.set(item.value, item);\n            }\n\n            // map item values to items\n            for (const value of params.getAll(key)) {\n                const existingFilter = groupItemsByValue.get(\n                    getValueFromFilterString(value)\n                );\n\n                if (existingFilter) {\n                    items.add(existingFilter);\n                } else {\n                    console.warn(\n                        `Existing filter ${value} not found in possible filters`\n                    );\n                }\n            }\n\n            // add items to the next state, keyed by group\n            nextState.set(group, items);\n        }\n    }\n\n    return nextState;\n};\n\n/**\n * Looks for filter values within a search string and returns a map like\n * {\n *   \"category_id\": [\"Bottoms,28\", \"Pants & Shorts,19\"]\n * }\n * filter[category_id]=Bottoms,28&filter[category_id]=Pants & Shorts,19\n * @param {String} initialValue a search string, as in from location.search\n */\nexport const getFiltersFromSearch = initialValue => {\n    // preserve all existing params\n    const params = new URLSearchParams(initialValue);\n    const uniqueKeys = new Set(params.keys());\n    const filters = new Map();\n\n    // iterate over existing param keys\n    for (const key of uniqueKeys) {\n        // if a key matches a known filter, add its items to the next state\n        if (key.endsWith('[filter]')) {\n            // derive the group by slicing off `[filter]`\n            const group = key.slice(0, -8);\n            const items = new Set();\n\n            // map item values to items\n            for (const value of params.getAll(key)) {\n                items.add(value);\n            }\n\n            // add items to the next state, keyed by group\n            filters.set(group, items);\n        }\n    }\n\n    return filters;\n};\n\nexport const stripHtml = html => html.replace(/(<([^>]+)>)/gi, '');\n\n/** GetFilterInput helpers below. */\nconst getValueFromFilterString = keyValueString =>\n    keyValueString.split(DELIMITER)[1];\n\n/**\n * Converts a set of values to a range filter\n * @param {Set} values\n */\nconst toRangeFilter = values => {\n    // Range should always only be a single string. In the event we received\n    // multiple, just return the first.\n    const rangeString = getValueFromFilterString(Array.from(values)[0]);\n\n    const [from, to] = rangeString.split('_');\n    const rangeFilter = {\n        from,\n        to\n    };\n\n    if (rangeFilter.from === '*') {\n        delete rangeFilter.from;\n    }\n    if (rangeFilter.to === '*') {\n        delete rangeFilter.to;\n    }\n    return rangeFilter;\n};\n\n/**\n * Converts a set of values into an equals filter\n * @param {Set} values\n */\nconst toEqualFilter = values => {\n    if (values.size > 1) {\n        return {\n            in: Array.from(values).map(getValueFromFilterString)\n        };\n    } else {\n        return {\n            eq: getValueFromFilterString(Array.from(values)[0])\n        };\n    }\n};\n\n/**\n * Converts a set of values into a match filter\n * @param {Set} values\n */\nconst toMatchFilter = values => {\n    return { match: getValueFromFilterString(Array.from(values)[0]) };\n};\n\nconst CONVERSION_FUNCTIONS = {\n    FilterEqualTypeInput: toEqualFilter,\n    FilterMatchTypeInput: toMatchFilter,\n    FilterRangeTypeInput: toRangeFilter\n};\n\n/**\n * Returns a filter input object matching the type provided.\n *\n * @param values - A set of values to construct the result object from.\n * @param type - Any of the possible types of filter input types\n */\nexport const getFilterInput = (values, type) => {\n    const conversionFunction = CONVERSION_FUNCTIONS[type];\n    if (!conversionFunction) {\n        throw TypeError(`Unknown type ${type}`);\n    }\n\n    return conversionFunction(values);\n};\n"]}