{"version":3,"sources":["useProductFullDetail.js"],"names":["INITIAL_OPTION_CODES","Map","INITIAL_OPTION_SELECTIONS","deriveOptionCodesFromProduct","product","initialOptionCodes","attribute_id","attribute_code","configurable_options","set","deriveOptionSelectionsFromProduct","initialOptionSelections","undefined","getIsMissingOptions","optionSelections","numProductOptions","length","numProductSelections","Array","from","values","filter","value","getMediaGalleryEntries","optionCodes","media_gallery_entries","variants","isConfigurable","optionsSelected","item","getBreadcrumbCategoryId","categories","breadcrumbSet","Set","forEach","breadcrumbs","category_id","add","leafCategory","find","category","has","id","getConfigPrice","price","regularPrice","amount","SUPPORTED_PRODUCT_TYPES","useProductFullDetail","props","addConfigurableProductToCartMutation","addSimpleProductToCartMutation","productType","__typename","isSupportedProductType","includes","cartId","addConfigurableProductToCart","error","errorAddingConfigurableProduct","loading","isAddConfigurableLoading","addSimpleProductToCart","errorAddingSimpleProduct","isAddSimpleLoading","breadcrumbCategoryId","derivedOptionSelections","setOptionSelections","derivedOptionCodes","isMissingOptions","mediaGalleryEntries","handleAddToCart","formValues","quantity","payload","variables","parentSku","sku","console","handleSelectionChange","optionId","selection","nextOptionSelections","productPrice","productDetails","description","name","derivedErrorMessage","errorMessage","isAddToCartDisabled"],"mappings":"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","sourcesContent":["import { useCallback, useState, useMemo } from 'react';\nimport { useMutation } from '@apollo/client';\nimport { useCartContext } from '@magento/peregrine/lib/context/cart';\n\nimport { appendOptionsToPayload } from '@magento/peregrine/lib/util/appendOptionsToPayload';\nimport { findMatchingVariant } from '@magento/peregrine/lib/util/findMatchingProductVariant';\nimport { isProductConfigurable } from '@magento/peregrine/lib/util/isProductConfigurable';\nimport { deriveErrorMessage } from '../../util/deriveErrorMessage';\n\nconst INITIAL_OPTION_CODES = new Map();\nconst INITIAL_OPTION_SELECTIONS = new Map();\n\nconst deriveOptionCodesFromProduct = product => {\n    // If this is a simple product it has no option codes.\n    if (!isProductConfigurable(product)) {\n        return INITIAL_OPTION_CODES;\n    }\n\n    // Initialize optionCodes based on the options of the product.\n    const initialOptionCodes = new Map();\n    for (const {\n        attribute_id,\n        attribute_code\n    } of product.configurable_options) {\n        initialOptionCodes.set(attribute_id, attribute_code);\n    }\n\n    return initialOptionCodes;\n};\n\n// Similar to deriving the initial codes for each option.\nconst deriveOptionSelectionsFromProduct = product => {\n    if (!isProductConfigurable(product)) {\n        return INITIAL_OPTION_SELECTIONS;\n    }\n\n    const initialOptionSelections = new Map();\n    for (const { attribute_id } of product.configurable_options) {\n        initialOptionSelections.set(attribute_id, undefined);\n    }\n\n    return initialOptionSelections;\n};\n\nconst getIsMissingOptions = (product, optionSelections) => {\n    // Non-configurable products can't be missing options.\n    if (!isProductConfigurable(product)) {\n        return false;\n    }\n\n    // Configurable products are missing options if we have fewer\n    // option selections than the product has options.\n    const { configurable_options } = product;\n    const numProductOptions = configurable_options.length;\n    const numProductSelections = Array.from(optionSelections.values()).filter(\n        value => !!value\n    ).length;\n\n    return numProductSelections < numProductOptions;\n};\n\nconst getMediaGalleryEntries = (product, optionCodes, optionSelections) => {\n    let value = [];\n\n    const { media_gallery_entries, variants } = product;\n    const isConfigurable = isProductConfigurable(product);\n\n    // Selections are initialized to \"code => undefined\". Once we select a value, like color, the selections change. This filters out unselected options.\n    const optionsSelected =\n        Array.from(optionSelections.values()).filter(value => !!value).length >\n        0;\n\n    if (!isConfigurable || !optionsSelected) {\n        value = media_gallery_entries;\n    } else {\n        // If any of the possible variants matches the selection add that\n        // variant's image to the media gallery. NOTE: This _can_, and does,\n        // include variants such as size. If Magento is configured to display\n        // an image for a size attribute, it will render that image.\n        const item = findMatchingVariant({\n            optionCodes,\n            optionSelections,\n            variants\n        });\n\n        value = item\n            ? [...item.product.media_gallery_entries, ...media_gallery_entries]\n            : media_gallery_entries;\n    }\n\n    return value;\n};\n\n// We only want to display breadcrumbs for one category on a PDP even if a\n// product has multiple related categories. This function filters and selects\n// one category id for that purpose.\nconst getBreadcrumbCategoryId = categories => {\n    // Exit if there are no categories for this product.\n    if (!categories || !categories.length) {\n        return;\n    }\n    const breadcrumbSet = new Set();\n    categories.forEach(({ breadcrumbs }) => {\n        // breadcrumbs can be `null`...\n        (breadcrumbs || []).forEach(({ category_id }) =>\n            breadcrumbSet.add(category_id)\n        );\n    });\n\n    // Until we can get the single canonical breadcrumb path to a product we\n    // will just return the first category id of the potential leaf categories.\n    const leafCategory = categories.find(\n        category => !breadcrumbSet.has(category.id)\n    );\n\n    // If we couldn't find a leaf category then just use the first category\n    // in the list for this product.\n    return leafCategory.id || categories[0].id;\n};\n\nconst getConfigPrice = (product, optionCodes, optionSelections) => {\n    let value;\n\n    const { variants } = product;\n    const isConfigurable = isProductConfigurable(product);\n\n    const optionsSelected =\n        Array.from(optionSelections.values()).filter(value => !!value).length >\n        0;\n\n    if (!isConfigurable || !optionsSelected) {\n        value = product.price.regularPrice.amount;\n    } else {\n        const item = findMatchingVariant({\n            optionCodes,\n            optionSelections,\n            variants\n        });\n\n        value = item\n            ? item.product.price.regularPrice.amount\n            : product.price.regularPrice.amount;\n    }\n\n    return value;\n};\n\nconst SUPPORTED_PRODUCT_TYPES = ['SimpleProduct', 'ConfigurableProduct'];\n\n/**\n * @param {GraphQLQuery} props.addConfigurableProductToCartMutation - configurable product mutation\n * @param {GraphQLQuery} props.addSimpleProductToCartMutation - configurable product mutation\n * @param {Object} props.product - the product, see RootComponents/Product\n *\n * @returns {{\n *  breadcrumbCategoryId: string|undefined,\n *  errorMessage: string|undefined,\n *  handleAddToCart: func,\n *  handleSelectionChange: func,\n *  handleSetQuantity: func,\n *  isAddToCartDisabled: boolean,\n *  mediaGalleryEntries: array,\n *  productDetails: object,\n *  quantity: number\n * }}\n */\nexport const useProductFullDetail = props => {\n    const {\n        addConfigurableProductToCartMutation,\n        addSimpleProductToCartMutation,\n        product\n    } = props;\n\n    const productType = product.__typename;\n\n    const isSupportedProductType = SUPPORTED_PRODUCT_TYPES.includes(\n        productType\n    );\n\n    const [{ cartId }] = useCartContext();\n\n    const [\n        addConfigurableProductToCart,\n        {\n            error: errorAddingConfigurableProduct,\n            loading: isAddConfigurableLoading\n        }\n    ] = useMutation(addConfigurableProductToCartMutation);\n\n    const [\n        addSimpleProductToCart,\n        { error: errorAddingSimpleProduct, loading: isAddSimpleLoading }\n    ] = useMutation(addSimpleProductToCartMutation);\n\n    const breadcrumbCategoryId = useMemo(\n        () => getBreadcrumbCategoryId(product.categories),\n        [product.categories]\n    );\n\n    const derivedOptionSelections = useMemo(\n        () => deriveOptionSelectionsFromProduct(product),\n        [product]\n    );\n\n    const [optionSelections, setOptionSelections] = useState(\n        derivedOptionSelections\n    );\n\n    const derivedOptionCodes = useMemo(\n        () => deriveOptionCodesFromProduct(product),\n        [product]\n    );\n    const [optionCodes] = useState(derivedOptionCodes);\n\n    const isMissingOptions = useMemo(\n        () => getIsMissingOptions(product, optionSelections),\n        [product, optionSelections]\n    );\n    const mediaGalleryEntries = useMemo(\n        () => getMediaGalleryEntries(product, optionCodes, optionSelections),\n        [product, optionCodes, optionSelections]\n    );\n\n    const handleAddToCart = useCallback(\n        async formValues => {\n            const { quantity } = formValues;\n            const payload = {\n                item: product,\n                productType,\n                quantity\n            };\n\n            if (isProductConfigurable(product)) {\n                appendOptionsToPayload(payload, optionSelections, optionCodes);\n            }\n\n            if (isSupportedProductType) {\n                const variables = {\n                    cartId,\n                    parentSku: payload.parentSku,\n                    product: payload.item,\n                    quantity: payload.quantity,\n                    sku: payload.item.sku\n                };\n                // Use the proper mutation for the type.\n                if (productType === 'SimpleProduct') {\n                    try {\n                        await addSimpleProductToCart({\n                            variables\n                        });\n                    } catch {\n                        return;\n                    }\n                } else if (productType === 'ConfigurableProduct') {\n                    try {\n                        await addConfigurableProductToCart({\n                            variables\n                        });\n                    } catch {\n                        return;\n                    }\n                }\n            } else {\n                console.error('Unsupported product type. Cannot add to cart.');\n            }\n        },\n        [\n            addConfigurableProductToCart,\n            addSimpleProductToCart,\n            cartId,\n            isSupportedProductType,\n            optionCodes,\n            optionSelections,\n            product,\n            productType\n        ]\n    );\n\n    const handleSelectionChange = useCallback(\n        (optionId, selection) => {\n            // We must create a new Map here so that React knows that the value\n            // of optionSelections has changed.\n            const nextOptionSelections = new Map([...optionSelections]);\n            nextOptionSelections.set(optionId, selection);\n            setOptionSelections(nextOptionSelections);\n        },\n        [optionSelections]\n    );\n\n    const productPrice = useMemo(\n        () => getConfigPrice(product, optionCodes, optionSelections),\n        [product, optionCodes, optionSelections]\n    );\n\n    // Normalization object for product details we need for rendering.\n    const productDetails = {\n        description: product.description,\n        name: product.name,\n        price: productPrice,\n        sku: product.sku\n    };\n\n    const derivedErrorMessage = useMemo(\n        () =>\n            deriveErrorMessage([\n                errorAddingSimpleProduct,\n                errorAddingConfigurableProduct\n            ]),\n        [errorAddingConfigurableProduct, errorAddingSimpleProduct]\n    );\n\n    return {\n        breadcrumbCategoryId,\n        errorMessage: derivedErrorMessage,\n        handleAddToCart,\n        handleSelectionChange,\n        isAddToCartDisabled:\n            !isSupportedProductType ||\n            isMissingOptions ||\n            isAddConfigurableLoading ||\n            isAddSimpleLoading,\n        mediaGalleryEntries,\n        productDetails\n    };\n};\n"]}