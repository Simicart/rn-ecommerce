{"version":3,"sources":["resolveUnknownRoute.js"],"names":["BrowserPersistence","persistence","getRouteCacheKey","store","numRE","castDigitsToNum","str","test","Number","resolveUnknownRoute","opts","route","apiBase","preloadDone","preloadAttrs","document","body","dataset","modelType","type","id","modelId","preloadScript","getElementById","preload","JSON","parse","textContent","e","process","env","NODE_ENV","console","error","preloaded","remotelyResolveRoute","urlResolve","getItem","navigator","onLine","Promise","resolve","data","urlResolver","fetchRoute","query","url","URL","searchParams","set","stringify","headers","fetch","method","credentials","Headers","then","res","json","errors","Error","routes","setItem"],"mappings":"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","sourcesContent":["import BrowserPersistence from '../util/simplePersistence';\n/**\n * @description Given a route string, resolves with the \"standard route\", along\n * with the assigned Root Component (and its owning chunk) from the backend\n * @param {{ route: string, apiBase: string, __tmp_webpack_public_path__: string}} opts\n */\nconst persistence = new BrowserPersistence();\n\n/**\n * Retrieve the route cache key for a store\n *\n * @param store\n * @returns {*}\n */\nfunction getRouteCacheKey(store) {\n    return 'urlResolver' + (store ? `_${store}` : '');\n}\n\n// Some M2.3.0 GraphQL node IDs are numbers and some are strings, so explicitly\n// cast numbers if they appear to be numbers\nconst numRE = /^\\d+$/;\nconst castDigitsToNum = str =>\n    typeof str === 'string' && numRE.test(str) ? Number(str) : str;\nexport default async function resolveUnknownRoute(opts) {\n    const { route, apiBase, store } = opts;\n\n    if (!resolveUnknownRoute.preloadDone) {\n        resolveUnknownRoute.preloadDone = true;\n\n        // Templates may use the new style (data attributes on the body tag),\n        // or the old style (handwritten JSON in a script element).\n\n        // New style:\n        const preloadAttrs = document.body.dataset;\n        if (preloadAttrs && preloadAttrs.modelType) {\n            return {\n                type: preloadAttrs.modelType,\n                id: castDigitsToNum(preloadAttrs.modelId)\n            };\n        }\n\n        // Old style:\n        const preloadScript = document.getElementById('url-resolver');\n        if (preloadScript) {\n            try {\n                const preload = JSON.parse(preloadScript.textContent);\n                return {\n                    type: preload.type,\n                    id: castDigitsToNum(preload.id)\n                };\n            } catch (e) {\n                // istanbul ignore next: will never happen in test\n                if (process.env.NODE_ENV === 'development') {\n                    console.error(\n                        'Unable to read preload!',\n                        preloaded.textContent,\n                        e\n                    );\n                }\n            }\n        }\n    }\n\n    return remotelyResolveRoute({\n        route,\n        apiBase,\n        store\n    });\n}\n\n/**\n * @description Checks if route is stored in localStorage, if not call `fetchRoute`\n * @param {{ route: string, apiBase: string, store: string }} opts\n * @returns {Promise<{type: \"PRODUCT\" | \"CATEGORY\" | \"CMS_PAGE\"}>}\n */\nfunction remotelyResolveRoute(opts) {\n    const urlResolve = persistence.getItem(getRouteCacheKey(opts.store));\n\n    // If it exists in localStorage, use that value\n    // TODO: This can be handled by workbox once this issue is resolved in the\n    // graphql repo: https://github.com/magento/graphql-ce/issues/229\n    if ((urlResolve && urlResolve[opts.route]) || !navigator.onLine) {\n        if (urlResolve && urlResolve[opts.route]) {\n            return Promise.resolve(urlResolve[opts.route].data.urlResolver);\n        } else {\n            return Promise.resolve({\n                type: 'NOTFOUND',\n                id: -1\n            });\n        }\n    } else {\n        return fetchRoute(opts);\n    }\n}\n\n/**\n * @description Calls remote endpoints to see if anything can handle this route.\n * @param {{ route: string, apiBase: string, store: ?string }} opts\n * @returns {Promise<{type: \"PRODUCT\" | \"CATEGORY\" | \"CMS_PAGE\"}>}\n */\nfunction fetchRoute(opts) {\n    const query = `query ResolveURL($url: String!) {\n        urlResolver(url: $url) {\n            type\n            id\n            relative_url\n            redirectCode\n        }\n    }`;\n\n    const url = new URL('/graphql', opts.apiBase);\n    url.searchParams.set('query', query);\n    url.searchParams.set('variables', JSON.stringify({ url: opts.route }));\n    url.searchParams.set('operationName', 'ResolveURL');\n\n    const headers = {\n        'Content-Type': 'application/json'\n    };\n\n    // If the store is provided include it as part of the request\n    if (opts.store) {\n        headers['Store'] = opts.store;\n    }\n\n    return fetch(url, {\n        method: 'GET',\n        credentials: 'include',\n        headers: new Headers(headers)\n    })\n        .then(res => res.json())\n        .then(res => {\n            if (res.errors) {\n                throw new Error(\n                    `urlResolver query failed: ${JSON.stringify(\n                        res.errors,\n                        null,\n                        2\n                    )}`\n                );\n            }\n\n            const routes =\n                persistence.getItem(getRouteCacheKey(opts.store)) || {};\n            routes[opts.route] = res;\n            persistence.setItem(getRouteCacheKey(opts.store), routes, 86400);\n            // entire route cache has a TTL of one day\n\n            return res.data.urlResolver;\n        });\n}\n"]}