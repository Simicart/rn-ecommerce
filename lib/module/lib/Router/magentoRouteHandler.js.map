{"version":3,"sources":["magentoRouteHandler.js"],"names":["React","Component","func","shape","string","resolveUnknownRoute","InternalError","Symbol","NotFound","mountedInstances","WeakSet","MagentoRouteHandler","componentMap","Map","errorState","hasError","internalError","notFound","componentDidMount","pathname","props","location","isSearch","add","getRouteComponent","componentDidUpdate","state","isKnown","has","isNotFoundComponent","get","id","shouldReloadRoute","navigator","onLine","componentWillUnmount","delete","apiBase","fetchRoot","fetchRootComponent","default","resolvedRoute","route","Error","type","RootComponent","setRouteComponent","e","process","env","NODE_ENV","console","error","symbol","message","meta","setState","set","renderChildren","loading","children","render","routeProps","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { func, shape, string } from 'prop-types';\n\n// 2019-01-28 Removed virtual `FETCH_ROOT_COMPONENT` import. It's much cleaner\n// to inject a \"fetchRootComponent\" global at build time, so that's what we\n// changed the MagentoRootComponentsPlugin to do.\nimport resolveUnknownRoute from './resolveUnknownRoute';\n\nconst InternalError = Symbol('InternalError');\nconst NotFound = Symbol('NotFound');\nconst mountedInstances = new WeakSet();\n\nexport default class MagentoRouteHandler extends Component {\n    static propTypes = {\n        apiBase: string.isRequired,\n        children: func,\n        location: shape({\n            pathname: string.isRequired\n        }).isRequired\n    };\n\n    state = {\n        componentMap: new Map(),\n        errorState: {\n            hasError: false,\n            internalError: false,\n            notFound: false\n        }\n    };\n\n    componentDidMount() {\n        const { pathname } = this.props.location;\n        const isSearch = pathname === '/search.html';\n        mountedInstances.add(this);\n        if (!isSearch) {\n            this.getRouteComponent(pathname);\n        }\n    }\n\n    componentDidUpdate() {\n        const { props, state } = this;\n        const { pathname } = props.location;\n        const isKnown = state.componentMap.has(pathname);\n        const isSearch = pathname === '/search.html';\n\n        // `NOTFOUND` component needs a unique id\n        // currently it is set to -1\n        const isNotFoundComponent = isKnown\n            ? state.componentMap.get(pathname).id === -1\n            : false;\n\n        const shouldReloadRoute = isNotFoundComponent && navigator.onLine;\n\n        if ((!isKnown && !isSearch) || shouldReloadRoute) {\n            this.getRouteComponent();\n        }\n    }\n\n    componentWillUnmount() {\n        mountedInstances.delete(this);\n    }\n\n    async getRouteComponent() {\n        const {\n            apiBase,\n            location: { pathname }\n        } = this.props;\n\n        // Depending on the environment, the fetchRootComponent global can be\n        // either an ES module with a `default` property or a plain CJS module.\n        const fetchRoot =\n            'default' in fetchRootComponent\n                ? fetchRootComponent.default\n                : fetchRootComponent;\n\n        try {\n            // try to resolve the route\n            // if this throws, we essentially have a 500 Internal Error\n            const resolvedRoute = await resolveUnknownRoute({\n                apiBase,\n                route: pathname\n            });\n\n            // urlResolver query returns null if a route can't be found\n            if (!resolvedRoute) {\n                throw new Error('404');\n            }\n\n            const { type, id } = resolvedRoute;\n            // if resolution and destructuring succeed but return no match\n            // then we have a straightforward 404 Not Found\n            if (!type || !id) {\n                throw new Error('404');\n            }\n\n            // at this point we should have a matching RootComponent\n            // if this throws, we essentially have a 500 Internal Error\n            const RootComponent = await fetchRoot(type);\n\n            // associate the matching RootComponent with this location\n            this.setRouteComponent(pathname, RootComponent, { id });\n        } catch (e) {\n            if (process.env.NODE_ENV === 'development') {\n                console.error(e);\n            }\n\n            const symbol = e.message === '404' ? NotFound : InternalError;\n\n            // we don't have a matching RootComponent, but we've checked for one\n            // so associate the appropriate error case with this location\n            this.setRouteComponent(pathname, symbol);\n        }\n    }\n\n    setRouteComponent(pathname, RootComponent, meta) {\n        if (!mountedInstances.has(this)) {\n            // avoid setState if component is not mounted for any reason\n            return;\n        }\n\n        this.setState(({ componentMap }) => ({\n            componentMap: new Map(componentMap).set(pathname, {\n                RootComponent,\n                ...meta\n            }),\n            errorState: {\n                hasError: typeof RootComponent === 'symbol',\n                internalError: RootComponent === InternalError,\n                notFound: RootComponent === NotFound\n            }\n        }));\n    }\n\n    renderChildren(loading) {\n        const { props, state } = this;\n        const { children } = props;\n        const { errorState } = state;\n\n        return typeof children === 'function'\n            ? children({ ...errorState, loading })\n            : null;\n    }\n\n    render() {\n        const { props, state } = this;\n        const { pathname } = props.location;\n        const { componentMap, errorState } = state;\n\n        // if we have no record of this pathname, we're still loading\n        // and we have no RootComponent, so render children\n        if (!componentMap.has(pathname)) {\n            return this.renderChildren(true);\n        }\n\n        // if we're in an error state, we're not loading anymore\n        // but we have no RootComponent, so render children\n        if (errorState.hasError) {\n            return this.renderChildren(false);\n        }\n\n        // otherwise we do have a RootComponent, so render it\n        const { RootComponent, ...routeProps } = componentMap.get(pathname);\n\n        return <RootComponent {...routeProps} key={pathname} />;\n    }\n}\n"]}