{"version":3,"sources":["getRouteComponent.js"],"names":["resolveUnknownRoute","INTERNAL_ERROR","NOT_FOUND","getRouteComponent","apiBase","pathname","store","fetchRoot","fetchRootComponent","default","resolvedRoute","route","Error","type","id","redirectCode","relative_url","component","relativeUrl","e","routeError","message","console","error"],"mappings":"AAAA,OAAOA,mBAAP,MAAgC,kCAAhC;AAEA,OAAO,MAAMC,cAAc,GAAG,gBAAvB;AACP,OAAO,MAAMC,SAAS,GAAG,WAAlB;AAEP;;;;;;;;;AAQA,MAAMC,iBAAiB,GAAG,OAAOC,OAAP,EAAgBC,QAAhB,EAA0BC,KAA1B,KAAoC;AAC1D;AACA;AACA;AACA,QAAMC,SAAS,GACX,aAAaC,kBAAb,GACMA,kBAAkB,CAACC,OADzB,GAEMD,kBAHV;;AAKA,MAAI;AACA;AACA;AACA,UAAME,aAAa,GAAG,MAAMV,mBAAmB,CAAC;AAC5CI,MAAAA,OAD4C;AAE5CO,MAAAA,KAAK,EAAEN,QAFqC;AAG5CC,MAAAA,KAAK,EAAEA;AAHqC,KAAD,CAA/C,CAHA,CASA;;AACA,QAAI,CAACI,aAAL,EAAoB;AAChB,YAAM,IAAIE,KAAJ,CAAU,KAAV,CAAN;AACH;;AAED,UAAM;AAAEC,MAAAA,IAAF;AAAQC,MAAAA,EAAR;AAAYC,MAAAA,YAAZ;AAA0BC,MAAAA;AAA1B,QAA2CN,aAAjD,CAdA,CAeA;AACA;;AACA,QAAI,CAACG,IAAD,IAAS,CAACC,EAAd,EAAkB;AACd,YAAM,IAAIF,KAAJ,CAAU,KAAV,CAAN;AACH,KAnBD,CAqBA;AACA;;;AACA,UAAMK,SAAS,GAAG,MAAMV,SAAS,CAACM,IAAD,CAAjC,CAvBA,CAyBA;;AACA,WAAO;AACHI,MAAAA,SADG;AAEHH,MAAAA,EAFG;AAGHT,MAAAA,QAHG;AAIHQ,MAAAA,IAJG;AAKHE,MAAAA,YALG;AAMHG,MAAAA,WAAW,EAAEF;AANV,KAAP;AAQH,GAlCD,CAkCE,OAAOG,CAAP,EAAU;AACR,UAAMC,UAAU,GAAGD,CAAC,CAACE,OAAF,KAAc,KAAd,GAAsBnB,SAAtB,GAAkCD,cAArD;AAEAqB,IAAAA,OAAO,CAACC,KAAR,CAAcJ,CAAd,EAHQ,CAKR;AACA;;AACA,WAAO;AAAEd,MAAAA,QAAF;AAAYe,MAAAA;AAAZ,KAAP;AACH;AACJ,CApDD;;AAsDA,eAAejB,iBAAf","sourcesContent":["import resolveUnknownRoute from '../../Router/resolveUnknownRoute';\n\nexport const INTERNAL_ERROR = 'INTERNAL_ERROR';\nexport const NOT_FOUND = 'NOT_FOUND';\n\n/**\n * Get the route component for a specific path\n *\n * @param apiBase\n * @param pathname\n * @param store\n * @returns {Promise<{component: *, id: *, type: *, redirectCode: *, relativeUrl: *, pathname: *}|{routeError: *, pathname: *}>}\n */\nconst getRouteComponent = async (apiBase, pathname, store) => {\n    // At build time, `fetchRootComponent` is injected as a global.\n    // Depending on the environment, this global will be either an\n    // ES module with a `default` property, or a plain CJS module.\n    const fetchRoot =\n        'default' in fetchRootComponent\n            ? fetchRootComponent.default\n            : fetchRootComponent;\n\n    try {\n        // try to resolve the route\n        // if this throws, we essentially have a 500 Internal Error\n        const resolvedRoute = await resolveUnknownRoute({\n            apiBase,\n            route: pathname,\n            store: store\n        });\n\n        // urlResolver query returns null if a route can't be found\n        if (!resolvedRoute) {\n            throw new Error('404');\n        }\n\n        const { type, id, redirectCode, relative_url } = resolvedRoute;\n        // if resolution and destructuring succeed but return no match\n        // then we have a straightforward 404 Not Found\n        if (!type || !id) {\n            throw new Error('404');\n        }\n\n        // at this point we should have a matching RootComponent\n        // if this throws, we essentially have a 500 Internal Error\n        const component = await fetchRoot(type);\n\n        // associate the matching RootComponent with this location\n        return {\n            component,\n            id,\n            pathname,\n            type,\n            redirectCode,\n            relativeUrl: relative_url\n        };\n    } catch (e) {\n        const routeError = e.message === '404' ? NOT_FOUND : INTERNAL_ERROR;\n\n        console.error(e);\n\n        // we don't have a matching RootComponent, but we've checked for one\n        // so associate the appropriate error case with this location\n        return { pathname, routeError };\n    }\n};\n\nexport default getRouteComponent;\n"]}