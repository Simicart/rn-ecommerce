{"version":3,"sources":["asyncActions.js"],"names":["clearCartDataFromCache","BrowserPersistence","signOut","actions","storage","createCart","payload","thunk","dispatch","getState","fetchCartId","cart","cartId","getCart","request","retrieveCartId","receive","data","errors","fetchPolicy","receivePayload","Error","saveCartId","error","addItemToCart","addItemMutation","fetchCartDetails","item","quantity","parentSku","writingImageToCache","writeImageToCache","addItem","user","isSignedIn","variables","product","sku","getCartDetails","shouldRetry","networkError","isInvalidCart","removeCart","arguments","updateItemInCart","cartItemId","productType","removeItem","updateItem","removeItemFromCart","id","itemId","shouldResetCart","apolloClient","getDetails","details","clearCartId","reset","getItem","setItem","retrieveImageCache","saveImageCache","cache","media_gallery_entries","media","image","find","m","position","imageCache","graphQLErrors","err","message","includes"],"mappings":"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","sourcesContent":["import { clearCartDataFromCache } from '../../../Apollo/clearCartDataFromCache';\nimport BrowserPersistence from '../../../util/simplePersistence';\nimport { signOut } from '../user';\nimport actions from './actions';\n\nconst storage = new BrowserPersistence();\n\nexport const createCart = payload =>\n    async function thunk(dispatch, getState) {\n        const { fetchCartId } = payload;\n        const { cart } = getState();\n\n        // if a cart already exists in the store, exit\n        if (cart.cartId) {\n            return;\n        }\n\n        // Request a new cart.\n        dispatch(actions.getCart.request());\n\n        // if a cart exists in storage, act like we just received it\n        const cartId = await retrieveCartId();\n        if (cartId) {\n            dispatch(actions.getCart.receive(cartId));\n            return;\n        }\n\n        try {\n            // errors can come from graphql and are not thrown\n            const { data, errors } = await fetchCartId({\n                fetchPolicy: 'no-cache'\n            });\n\n            let receivePayload;\n\n            if (errors) {\n                receivePayload = new Error(errors);\n            } else {\n                receivePayload = data.cartId;\n                // write to storage in the background\n                saveCartId(data.cartId);\n            }\n\n            dispatch(actions.getCart.receive(receivePayload));\n        } catch (error) {\n            // If we are unable to create a cart, the cart can't function, so\n            // we forcibly throw so the upstream actions won't retry.\n            dispatch(actions.getCart.receive(error));\n            throw new Error('Unable to create cart');\n        }\n    };\n\nexport const addItemToCart = (payload = {}) => {\n    const {\n        addItemMutation,\n        fetchCartDetails,\n        fetchCartId,\n        item,\n        quantity,\n        parentSku\n    } = payload;\n\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.addItem.request(payload));\n\n        const { cart, user } = getState();\n        const { cartId } = cart;\n        const { isSignedIn } = user;\n\n        try {\n            const variables = {\n                cartId,\n                parentSku,\n                product: item,\n                quantity,\n                sku: item.sku\n            };\n\n            await addItemMutation({\n                variables\n            });\n\n            // 2019-02-07  Moved these dispatches to the success clause of\n            // addItemToCart. The cart should only open on success.\n            // In the catch clause, this action creator calls its own thunk,\n            // so a successful retry will wind up here anyway.\n            await dispatch(\n                getCartDetails({\n                    fetchCartId,\n                    fetchCartDetails\n                })\n            );\n            dispatch(actions.addItem.receive());\n        } catch (error) {\n            dispatch(actions.addItem.receive(error));\n\n            const shouldRetry = !error.networkError && isInvalidCart(error);\n\n            // Only retry if the cart is invalid or the cartId is missing.\n            if (shouldRetry) {\n                if (isSignedIn) {\n                    // Since simple persistence just deletes auth token without\n                    // informing Redux, we need to perform the sign out action\n                    // to reset the user and cart slices back to initial state.\n                    await dispatch(signOut());\n                } else {\n                    // Delete the cached ID from local storage and Redux.\n                    // In contrast to the save, make sure storage deletion is\n                    // complete before dispatching the error--you don't want an\n                    // upstream action to try and reuse the known-bad ID.\n                    await dispatch(removeCart());\n                }\n\n                // then create a new one\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n\n                // and fetch details\n                await dispatch(\n                    getCartDetails({\n                        fetchCartId,\n                        fetchCartDetails\n                    })\n                );\n\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\n/**\n * Applies changes in options/quantity to a cart item.\n *\n * @param payload.cartItemId {Number} the id of the cart item we are updating\n * @param payload.item {Object} the new configuration item if changes are selected.\n * @param payload.quantity {Number} the quantity of the item being updated\n * @param payload.productType {String} 'ConfigurableProduct' or other.\n */\nexport const updateItemInCart = (payload = {}) => {\n    const {\n        cartItemId,\n        fetchCartDetails,\n        fetchCartId,\n        item,\n        productType,\n        quantity,\n        removeItem,\n        updateItem\n    } = payload;\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.updateItem.request(payload));\n\n        const { cart, user } = getState();\n        const { cartId } = cart;\n        const { isSignedIn } = user;\n\n        try {\n            if (productType === 'ConfigurableProduct') {\n                // You _must_ remove before adding or risk deleting the item\n                // entirely if only quantity has been modified.\n                await dispatch(\n                    removeItemFromCart({\n                        item: {\n                            id: cartItemId\n                        },\n                        fetchCartDetails,\n                        fetchCartId,\n                        removeItem\n                    })\n                );\n                await dispatch(\n                    addItemToCart({\n                        ...payload\n                    })\n                );\n            } else {\n                // If the product is a simple product we can just use the\n                // updateCartItems graphql mutation.\n                await updateItem({\n                    variables: {\n                        cartId,\n                        itemId: cartItemId,\n                        quantity\n                    }\n                });\n                // The configurable product conditional dispatches actions that\n                // each call getCartDetails. For simple items we must request\n                // details after the mutation completes. This may change when\n                // we migrate to the `cart` query for details, away from REST.\n                await dispatch(\n                    getCartDetails({\n                        fetchCartId,\n                        fetchCartDetails\n                    })\n                );\n            }\n\n            dispatch(actions.updateItem.receive());\n        } catch (error) {\n            dispatch(actions.updateItem.receive(error));\n\n            const shouldRetry = !error.networkError && isInvalidCart(error);\n            if (shouldRetry) {\n                // Delete the cached ID from local storage and Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await dispatch(removeCart());\n\n                // then create a new one\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n\n                // and fetch details\n                await dispatch(\n                    getCartDetails({\n                        fetchCartId,\n                        fetchCartDetails\n                    })\n                );\n\n                if (isSignedIn) {\n                    // The user is signed in and we just received their cart.\n                    // Retry this operation.\n                    return thunk(...arguments);\n                } else {\n                    // The user is a guest and just received a brand new (empty) cart.\n                    // Add the updated item to that cart.\n                    await dispatch(\n                        addItemToCart({\n                            ...payload\n                        })\n                    );\n                }\n            }\n        }\n    };\n};\n\nexport const removeItemFromCart = payload => {\n    const { item, fetchCartDetails, fetchCartId, removeItem } = payload;\n\n    return async function thunk(dispatch, getState) {\n        dispatch(actions.removeItem.request(payload));\n\n        const { cart } = getState();\n        const { cartId } = cart;\n\n        try {\n            await removeItem({\n                variables: {\n                    cartId,\n                    itemId: item.id\n                }\n            });\n\n            dispatch(actions.removeItem.receive());\n        } catch (error) {\n            dispatch(actions.removeItem.receive(error));\n\n            const shouldResetCart = !error.networkError && isInvalidCart(error);\n            if (shouldResetCart) {\n                // Delete the cached ID from local storage.\n                // The reducer handles clearing out the bad ID from Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await dispatch(removeCart());\n                // then create a new one\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n            }\n        }\n\n        await dispatch(\n            getCartDetails({\n                fetchCartId,\n                fetchCartDetails\n            })\n        );\n    };\n};\n\nexport const getCartDetails = payload => {\n    const { apolloClient, fetchCartId, fetchCartDetails } = payload;\n\n    return async function thunk(dispatch, getState) {\n        const { cart, user } = getState();\n        const { cartId } = cart;\n        const { isSignedIn } = user;\n\n        // if there isn't a cart, create one then retry this operation\n        if (!cartId) {\n            try {\n                await dispatch(\n                    createCart({\n                        fetchCartId\n                    })\n                );\n            } catch (error) {\n                // If creating a cart fails, all is not lost. Return so that the\n                // user can continue to at least browse the site.\n                return;\n            }\n            return thunk(...arguments);\n        }\n\n        // Once we have the cart id indicate that we are starting to make\n        // async requests for the details.\n        dispatch(actions.getDetails.request(cartId));\n\n        try {\n            const { data } = await fetchCartDetails({\n                variables: { cartId },\n                fetchPolicy: 'no-cache'\n            });\n            const { cart: details } = data;\n\n            dispatch(actions.getDetails.receive({ details }));\n        } catch (error) {\n            dispatch(actions.getDetails.receive(error));\n\n            const shouldResetCart = !error.networkError && isInvalidCart(error);\n            if (shouldResetCart) {\n                if (isSignedIn) {\n                    // Since simple persistence just deletes auth token without\n                    // informing Redux, we need to perform the sign out action\n                    // to reset the user and cart slices back to initial state.\n                    await dispatch(signOut());\n                } else {\n                    // Delete the cached ID from local storage.\n                    await dispatch(removeCart());\n                }\n\n                // Clear the cart data from apollo client if we get here and\n                // have an apolloClient.\n                if (apolloClient) {\n                    await clearCartDataFromCache(apolloClient);\n                }\n\n                // Create a new one\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n\n                // Retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\nexport const removeCart = () =>\n    async function thunk(dispatch) {\n        // Clear the cartId from local storage.\n        await clearCartId();\n\n        // Clear the cart info from the redux store.\n        dispatch(actions.reset());\n    };\n\n/* helpers */\nexport async function retrieveCartId() {\n    return storage.getItem('cartId');\n}\n\nexport async function saveCartId(id) {\n    return storage.setItem('cartId', id);\n}\n\nexport async function clearCartId() {\n    return storage.removeItem('cartId');\n}\n\nasync function retrieveImageCache() {\n    return storage.getItem('imagesBySku') || {};\n}\n\nasync function saveImageCache(cache) {\n    return storage.setItem('imagesBySku', cache);\n}\n\nexport async function writeImageToCache(item = {}) {\n    const { media_gallery_entries: media, sku } = item;\n\n    if (sku) {\n        const image = media && (media.find(m => m.position === 1) || media[0]);\n\n        if (image) {\n            const imageCache = await retrieveImageCache();\n\n            // if there is an image and it differs from cache\n            // write to cache and save in the background\n            if (imageCache[sku] !== image) {\n                imageCache[sku] = image;\n                saveImageCache(imageCache);\n\n                return image;\n            }\n        }\n    }\n}\n\n// Returns true if the cart is invalid.\nfunction isInvalidCart(error) {\n    return !!(\n        error.graphQLErrors &&\n        error.graphQLErrors.find(\n            err =>\n                err.message.includes('Could not find a cart') ||\n                err.message.includes(\"The cart isn't active\") ||\n                err.message.includes(\n                    'The current user cannot perform operations on cart'\n                )\n        )\n    );\n}\n"]}